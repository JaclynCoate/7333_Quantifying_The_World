---
title: "QTW Case Study Unit 2"
output: pdf_document
---

```{r }
library(tidyverse)
library(stringr)
library(magrittr)
```

## Introduction



```{r}

#Loading data locally, something is buggy with the github links
offline_txt = readLines("/Users/zmartygirl/Documents/MSDS_SMU/QTW_7333/cs2_data/offline.final.trace.txt")
online_txt = readLines("/Users/zmartygirl/Documents/MSDS_SMU/QTW_7333/cs2_data/online.final.trace.txt")

```

```{r}
#Functions from Provided Code
processLine = function(x)
{
tokens = strsplit(x, "[;=,]")[[1]]
if (length(tokens) == 10)
    return(NULL)
tmp = matrix(tokens[ - (1:10) ], , 4, byrow = TRUE)  #build a 4 column matrix mac,signal,scan,type
cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow(tmp), 6, #builds a 6 column matrix t,scanMac,x,y,z,angle
byrow = TRUE), tmp) #binds them together
}

#Find nearest neighbors with a new signal and subset Called in predXY
findNN = function(newSignal, trainSubset) {
  diffs = apply(trainSubset[ , 4:9], 1, 
                function(x) x - newSignal)
  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) )
  closest = order(dists)
  return(trainSubset[closest, 1:3 ])
}

# Function to Predict XY based on new signals, angles and the training data, and a given K
predXY = function(newSignals, newAngles, trainData, 
                  numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
    closeXY[[i]] = 
      findNN(newSignal = as.numeric(newSignals[i, ]), trainSS)
  }

  estXY = lapply(closeXY, 
                 function(x) sapply(x[ , 2:3], 
                                    function(x) mean(x[1:k])))
  estXY = do.call("rbind", estXY)
  return(estXY)
}

#Dont need???
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

roundOrientation = function(angles) {
  refs = seq(0, by = 45, length  = 9)
  q = sapply(angles, function(o) which.min(abs(o - refs)))
  c(refs[1:8], 0)[q]
}


selectTrain = function(angleNewObs, signals = NULL, m = 1){
  # m is the number of angles to keep between 1 and 5
  refs = seq(0, by = 45, length  = 8)
  nearestAngle = roundOrientation(angleNewObs)
  
  if (m %% 2 == 1) 
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
  else {
    m = m + 1
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
    if (sign(angleNewObs - nearestAngle) > -1) 
      angles = angles[ -1 ]
    else 
      angles = angles[ -m ]
  }
  angles = angles + nearestAngle
  angles[angles < 0] = angles[ angles < 0 ] + 360
  angles[angles > 360] = angles[ angles > 360 ] - 360
  angles = sort(angles) 
  
  offlineSubset = signals[ signals$angle %in% angles, ]
  reshapeSS(offlineSubset, varSignal = "avgSignal")
}
```

```{r}
off_lines = offline_txt[ substr(offline_txt, 1, 1) != "#" ]
offline = lapply(off_lines,processLine)
offline = as.data.frame(do.call("rbind", offline),stringsAsFactors = FALSE)
names(offline) = c("time", "scanMac", "posX", "posY", "posZ",
"orientation", "mac", "signal", "channel", "type")

offline$posXY = paste(offline$posX, offline$posY, sep = "-")
offline$orientation = as.integer(offline$orientation)
offline$angle = roundOrientation(offline$orientation)

```


```{r}
on_lines = online_txt[ substr(online_txt, 1, 1) != "#" ]
online = lapply(on_lines,processLine)
online = as.data.frame(do.call("rbind", online),stringsAsFactors = FALSE)
names(online) = c("time", "scanMac", "posX", "posY", "posZ",
"orientation", "mac", "signal", "channel", "type")

online$posXY = paste(online$posX, online$posY, sep = "-")
online$orientation = as.integer(online$orientation)

online$angle = roundOrientation(online$orientation)

```


```{r}
#Turning offline dataframe into pivot table
subMacs = names(sort(table(offline$mac), decreasing = TRUE))[1:7]
subMacs
offline1 = offline[ offline$mac %in% subMacs, ]

offline1$signal %<>% as.integer
offline_pivot<-select(offline1, -c(channel,scanMac)) %>% pivot_wider(names_from = mac,values_from = signal, values_fn = list(signal=mean))

offline_pivot$nas<-rowSums(is.na(offline_pivot))
offline_pivot = offline_pivot[offline_pivot$nas==0,]

head(offline_pivot)
```

```{r}
#Turning online dataframe into pivot table
subMacs = names(sort(table(online$mac), decreasing = TRUE))[1:7]
subMacs
online1 = online[ online$mac %in% subMacs, ]

online1$signal %<>% as.integer
online_pivot<-select(online1, -c(channel,scanMac)) %>% pivot_wider(names_from = mac,values_from = signal, values_fn = list(signal=mean))

online_pivot$nas<-rowSums(is.na(online_pivot))
online_pivot = online_pivot[online_pivot$nas==0,]

head(online_pivot)
```




```{r}
#Various Offline subsets

#With all available mac addresses
seven_mac_offline = data.frame(offline_pivot)

#With the original mac address removed as in the book
original_six_mac_offline = offline_pivot %>% select(-"00:0f:a3:39:dd:cd")

#With the other mac address removed
alternate_six_mac_offline = offline_pivot %>% select(-"00:0f:a3:39:e1:c0")

```

Original Analysis with Original Six mac addresses
```{r}
#code from book 
keepVars = c("posXY", "posX","posY", "orientation", "angle")
v = 11
permuteLocs = sample(unique(original_six_mac_offline$posXY))
permuteLocs = matrix(permuteLocs, ncol = v,  nrow = floor(length(permuteLocs)/v))

#onlineCVSummary = reshapeSS(online_pivot, keepVars = keepVars, sampleAngle = TRUE)

onlineFold = subset(online_pivot, posXY %in% permuteLocs[ , 1])

offlineFold = subset(original_six_mac_offline, posXY %in% permuteLocs[ , -1])

estFold = predXY(newSignals = onlineFold[ , 6:11], 
                 newAngles = onlineFold[ , 4], 
                 offlineFold, numAngles = 1, k = 3)

actualFold = onlineFold[ , c("posX", "posY")]
calcError(estFold, actualFold)

K = 20
err = rep(0, K)

for (j in 1:v) {
  onlineFold = subset(online_pivot, 
                      posXY %in% permuteLocs[ , j])
  offlineFold = subset(original_six_mac_offline,
                       posXY %in% permuteLocs[ , -j])
  actualFold = onlineFold[ , c("posX", "posY")]
  
  for (k in 1:K) {
    estFold = predXY(newSignals = onlineFold[ , 6:11],
                     newAngles = onlineFold[ , 4], 
                     offlineFold, numAngles = 1, k = k)
    err[k] = err[k] + calcError(estFold, actualFold)
  }
}


plot(y = err, x = (1:K),  type = "l", lwd= 2,
     ylim = c(800, 2100),
     xlab = "Number of Neighbors",
     ylab = "Sum of Square Errors")

rmseMin = min(err)
kMin = which(err == rmseMin)[1]
segments(x0 = 0, x1 = kMin, y0 = rmseMin, col = gray(0.4), 
         lty = 2, lwd = 2)
segments(x0 = kMin, x1 = kMin, y0 = 1100,  y1 = rmseMin, 
         col = grey(0.4), lty = 2, lwd = 2)

#mtext(kMin, side = 1, line = 1, at = kMin, col = grey(0.4))
text(x = kMin - 2, y = rmseMin + 40, 
     label = as.character(round(rmseMin)), col = grey(0.4))


estXYk5 = predXY(newSignals = onlineSummary[ , 6:11], 
                 newAngles = onlineSummary[ , 4], 
                 original_six_mac_offline, numAngles = 1, k = 5)

calcError(estXYk5, actualXY)



```
